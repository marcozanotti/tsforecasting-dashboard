---
title: "Forecasting Dashboard"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    css: css/styles-default.css
    logo: img/tsf_logo.png
    social: ["menu"]
    source_code: https://github.com/marcozanotti/tsforecasting-dashboard
    navbar:
      - { title: "About", href: "https://marcozanotti.netlify.app/", align: right }
      - { title: "Manual", href: "https://marcozanotti.github.io/tsforecasting-dashboard/manual/tsforecasting-manual.html", align: right }
runtime: shiny
---

```{r setup, include=FALSE, message=FALSE}
lapply(list.files("R", full.names = TRUE), source)

# Packages
pkgs <- c(
  "tidyverse", "tsibbledata", "janitor", "skimr", "vroom", "logging",
  "forecast", "prophet", "glmnet", "earth", "kernlab", "kknn",
  "randomForest", "ranger", "xgboost", "treesnip", "lightgbm",
  "Cubist", "rules",
  "tidymodels", 
  "modeltime", "modeltime.ensemble", "modeltime.resample", "modeltime.h2o",
  "plotly", "DT", "timetk",
  "DALEX", "DALEXtra",
  "rmarkdown", "flexdashboard",
  "shiny", "shinyWidgets", "shinyjs", "shinymanager"
)
install_and_load(pkgs)

set_options()
Sys.setenv(JAVA_HOME = "/usr/lib/jvm/jdk-17/")
logging::addHandler(logging::writeToFile, file = "tsf_dashboard.log")

datasets <- getOption("tsf.dashboard.datasets")
methods <- getOption("tsf.dashboard.methods")
ts_methods <- methods$ts
ml_methods <- methods$ml
dl_methods <- methods$dl
mix_methods <- methods$mix
aml_methods <- methods$aml
tune_methods <- methods$tune
ens_methods <- methods$ens
stk_methods <- methods$stk
# methods <- c(ts_methods, ml_methods, dl_methods, mix_methods)

mtd_prm <- getOption("tsf.dashboard.methods_params")
mtd_prm_names <- purrr::map(mtd_prm, names)

metrics <- toupper(getOption("tsf.dashboard.metrics"))

transf <- getOption("tsf.dashboard.transformations")
```



Data {data-orientation=rows}  
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
selectInput(
  inputId = "dataset", label = h4("Dataset"), 
  choices = datasets, selected = datasets[1], multiple = FALSE
)

h4("Upload your dataset: ")
h6("The dataset must be a .csv file containing columns 'date', 'id', 'frequency' and 'value'.")
fileInput(
  inputId = "upload_custom", label = NULL, accept = c(".csv"), multiple = FALSE,
  buttonLabel = "Browse...", placeholder = "No file"
)
actionButton(inputId = "data_import", label = "Import", icon = icon("upload"))
actionButton(inputId = "data_reset", label = "Reset", icon = icon("sync"))

br()
br()

prettyRadioButtons(
  inputId = "table_type", label = h5("Show:"), 
  choices = c("Preview", "Structure", "Summary")
)
```

```{r}
react_val <- reactiveValues(uploaded_data = NULL)

observeEvent(
  eventExpr = input$data_reset, 
  handlerExpr = {
  	updateSelectInput(session = session, inputId = "dataset", selected = datasets[1])
  	reset("upload_custom")
  	react_val$uploaded_data <- NULL
  }
)

observeEvent(
	eventExpr = input$data_import, 
  handlerExpr = {
    req(input$upload_custom)
    ext <- tools::file_ext(input$upload_custom$datapath)
    validate(need(ext == "csv", "Please upload a csv file"))
    updateSelectInput(session = session, inputId = "dataset", selected = "") # important to activate date_range input
    react_val$uploaded_data <- input$upload_custom
  }
)

data_selected <- reactive({
  if (is.null(react_val$uploaded_data)) {
  	get_data(input$dataset)
  } else {
    get_data("custom", path = react_val$uploaded_data$datapath)
  }
})

ts_freq <- reactive({
  data_selected()$frequency |> unique() |> parse_frequency()
})

output$data_table <- renderDT({
  data_selected() |>
      datatable(
        options = list(
          ordering = TRUE, pageLength = 20, lengthChange = TRUE, searching = TRUE, 
          info = FALSE, paging = TRUE, scrollCollapse = TRUE, scrollY = 700 # 250
        )
      )
})
output$data_str <- renderPrint({ str(data_selected()) })
output$data_summ <- renderPrint({ skim(data_selected()) })
```


Row 1 {data-height=100}
---------------------------------------------------------------------------

### 

```{r}
conditionalPanel(
  condition = "input.table_type == 'Preview'",
  DTOutput(outputId = "data_table")
)
conditionalPanel(
  condition = "input.table_type == 'Structure'",
  verbatimTextOutput(outputId = "data_str")
)
conditionalPanel(
  condition = "input.table_type == 'Summary'",
  verbatimTextOutput(outputId = "data_summ")
)
```



Visualize {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
dateRangeInput(
  inputId = "viz_date_range", label = h5("Date Period"),
  start = as.Date("1940-01-01"), end = as.Date("2023-12-31")
)

materialSwitch(
  inputId = "viz_smooth_line", label = h5("Smooth Line"), 
  value = TRUE, status = "primary", inline = TRUE
)

numericInput(
  inputId = "viz_acf_lag", label = h5("ACF Lag"),
  value = 48, min = 1, max = 300, step = 1, width = "45%"
)

br()

h5("Missing imputation")
switchInput(inputId = "impute", value = FALSE, size = "mini")

br()

actionButton(inputId = "viz_reset", label = "Reset", icon = icon("sync"))
```

```{r}
observeEvent(
  eventExpr = input$dataset,
  handlerExpr = {
    req(data_selected())
    updateDateRangeInput(
      session = session, inputId = "viz_date_range",
      start = min(data_selected()$date), end = max(data_selected()$date)
    )
  }
)

observeEvent(
  eventExpr = input$dataset, 
  handlerExpr = {
    updateNumericInput(
      session = session, inputId = "viz_acf_lag", 
      value = ifelse(ts_freq() < 60, ts_freq() * 3, 150), 
      min = 1, max = 300, step = 1
    )
  }
)

observeEvent(
  eventExpr = input$viz_reset, 
  handlerExpr = {
    updateMaterialSwitch(session = session, inputId = "viz_smooth_line", value = TRUE)
    updateNumericInput(session = session, inputId = "viz_acf_lag", value = ifelse(ts_freq() < 60, ts_freq() * 3, ts_freq()))
    updateSwitchInput(session = session, inputId = "viz_impute", value = FALSE)
  }
)

data_imputed <- reactive({
	req(data_selected())
  data_selected() |> 
    impute_data(impute = input$impute, freq = ts_freq())
})

data_visualized <- reactive({
	req(data_imputed())
  data_imputed() |> 
    filter(between(date, input$viz_date_range[1], input$viz_date_range[2]))
})

output$viz_ts_plot_smooth <- renderPlotly({
	req(data_visualized())
  data_visualized() |>
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = input$viz_smooth_line, # ifelse(ts_freq() > 60, FALSE, TRUE),
      .interactive = TRUE
    )
})

output$viz_autocorr_plot <- renderPlotly({
	req(data_visualized())
  data_visualized() |>
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, 
      .lags = input$viz_acf_lag, # ifelse(ts_freq() < 60, ts_freq() * 3, 150)
      .interactive = TRUE,
      .title = "Autocorrelation", .y_lab = NULL,
    )
})

output$viz_decomp_plot <- renderPlotly({
	req(data_visualized())
  data_visualized() |>
    timetk::plot_stl_diagnostics(
    	.date_var = date, .value = value, 
    	.feature_set = c("season", "trend", "remainder"), .interactive = TRUE,
    	.title = "Decomposition"
    )
})

output$viz_season_plot <- renderPlotly({
	req(data_visualized())
  data_visualized() |>
    timetk::plot_seasonal_diagnostics(
      .date_var = date, .value = value, 
      .interactive = TRUE, .title = "Seasonality"
    )
})
```


Row 1 {data-height=400}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
plotlyOutput(outputId = "viz_ts_plot_smooth")
```

### {.no-padding}

```{r}
plotlyOutput(outputId = "viz_autocorr_plot")
```


Row 2 {data-height=600}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
plotlyOutput(outputId = "viz_decomp_plot")
```

### {.no-padding}

```{r}
plotlyOutput(outputId = "viz_season_plot")
```



Hypothesis Testing {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
h3("Normality Tests")
h5("Shapiro-Wilk and Jarque-Bera")
br()

hr()
h3("Autocorrelation Tests")
h5("Ljung-Box and Box-Pierce")
br()

hr()
h3("Stationarity Tests")
h5("ADF, PP and KPSS")

br()
br()
br()
pickerInput(
  inputId = "test_transf", label = h5("Test on transformed data?"), multiple = TRUE,
  choices = transf, selected = NULL
)
```

```{r}
data_test <- reactive({
  data_imputed() |> 
    transform_data(transformations = input$test_transf,	freq = ts_freq()) |> 
		purrr::pluck("data_transformed")
})

test_results <- reactive({
  data_test() |> compute_hptests()
})

output$test_table <- renderDT({
  test_results() |>
    datatable(
      options = list(
        ordering = FALSE,
        pageLength = 20,
        lengthChange = FALSE,
        searching = FALSE,
        info = FALSE,
        paging = FALSE
      ), 
      rownames = FALSE
    )
})

output$test_dist_plot <- renderPlotly({
	g <- data_test() |>
		ggplot2::ggplot(ggplot2::aes(x = value)) +
    ggplot2::geom_density(fill = "lightblue", alpha = 0.5) +
    ggplot2::labs(title = "Distribution", x = NULL, y = NULL) +
    timetk:::theme_tq()
	plotly::ggplotly(g, dynamicTicks = TRUE)
})

output$test_ts_plot <- renderPlotly({
  data_test() |>
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = FALSE, .interactive = TRUE, .title = "Time Series Plot"
    )
})

output$test_autocorr_plot <- renderPlotly({
  data_test() |>
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, 
      .lags = ifelse(ts_freq() < 60, ts_freq() * 3, 150),
      .interactive = TRUE, .title = "Autocorrelation", .y_lab = NULL
    )
})
```


Row {data-height=500}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
DTOutput(outputId = "test_table")
```

### {.no-padding}

```{r}
plotlyOutput(outputId = "test_dist_plot")
```

Row {data-height=500}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
plotlyOutput(outputId = "test_ts_plot")
```

### {.no-padding}

```{r}
plotlyOutput(outputId = "test_autocorr_plot")
```



Anomaly Detection {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
h3("Anomaly Detection")

sliderInput(inputId = "alpha", label = h5("Confidence Level"), min = 0.01, max = 1, value = 0.02, step = 0.01)
sliderInput(inputId = "max_anomalies", label = h5("Max Anomalies (%)"), min = 0.01, max = 1, value = 0.1, step = 0.01)

hr()
h3("Anomaly Cleaning")
switchInput(inputId = "clean", value = FALSE, size = "mini")

br()

actionButton(inputId = "anomaly_reset", label = "Reset", icon = icon("sync"))
```

```{r}
observeEvent(
  eventExpr = input$anomaly_reset, 
  handlerExpr = {
    updateSliderInput(session = session, inputId = "alpha", value = 0.02)
    updateSliderInput(session = session, inputId = "max_anomalies", value = 0.1)
    updateSwitchInput(session = session, inputId = "clean", value = FALSE)
  }
)

data_cleaned <- reactive({
  data_imputed() |> 
		clean_data(clean = input$clean)
})

output$anomaly_plot <- renderPlotly({
  data_imputed() |>
    timetk::plot_anomaly_diagnostics(
      .date_var = date, .value = value, 
      .alpha = input$alpha, .max_anomalies = input$max_anomalies,
      .interactive = TRUE, .title = "Anomaly Plot", .legend_show = FALSE
    )
})

output$clean_plot <- renderPlotly({
  data_cleaned() |>
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = FALSE, .interactive = TRUE, 
      .title = "Cleaned Time Series"
    )
})
```


Row 1 {data-height=650}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
plotlyOutput(outputId = "anomaly_plot")
```


Row 2 {data-height=350}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
plotlyOutput(outputId = "clean_plot")
```



Transform {data-navmenu="Analyze" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
dateRangeInput(
  inputId = "transf_date_range", label = h5("Date Period"),
  start = as.Date("1940-01-01"), end = as.Date("2023-12-31")
)

materialSwitch(
  inputId = "transf_smooth_line", label = h5("Smooth Line"), 
  value = TRUE, status = "primary", inline = TRUE
)

numericInput(
  inputId = "transf_acf_lag", label = h5("ACF Lag"),
  value = 48, min = 1, max = 300, step = 1, width = "45%"
)

br()

pickerInput(
  inputId = "transf", label = h5("Transformations"), multiple = TRUE,
  choices = transf[1:7], selected = NULL # not possible to do Diff and SDiff !!!!!
)

br()

actionButton(inputId = "transf_reset", label = "Reset", icon = icon("sync"))
```

```{r}
observeEvent(
  eventExpr = input$dataset,
  handlerExpr = {
    req(data_selected())
    updateDateRangeInput(
      session = session, inputId = "transf_date_range",
      start = min(data_selected()$date), end = max(data_selected()$date)
    )
  }
)

observeEvent(
  eventExpr = input$dataset, 
  handlerExpr = {
    updateNumericInput(
      session = session, inputId = "transf_acf_lag", 
      value = ifelse(ts_freq() < 60, ts_freq() * 3, 150), 
      min = 1, max = 300, step = 1
    )
  }
)

observeEvent(
  eventExpr = input$transf_reset, 
  handlerExpr = {
    updateMaterialSwitch(session = session, inputId = "transf_smooth_line", value = TRUE)
    updateNumericInput(
    	session = session, inputId = "transf_acf_lag", 
    	value = ifelse(ts_freq() < 60, ts_freq() * 3, ts_freq())
    )
    updatePickerInput(session = session, inputId = "transf", selected = NULL)
  }
)

transform_params <- reactive({
	data_cleaned() |> 
    transform_data(transformations = input$transf,	freq = ts_freq()) |> 
		purrr::pluck("transform_params")
})

data_transformed <- reactive({
  data_cleaned() |> 
    transform_data(transformations = input$transf,	freq = ts_freq()) |> 
		purrr::pluck("data_transformed") |> 
    filter(between(date, input$transf_date_range[1], input$transf_date_range[2]))
})

output$transf_ts_plot_smooth <- renderPlotly({
  data_transformed() |>
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = input$transf_smooth_line, # ifelse(ts_freq() > 60, FALSE, TRUE),
      .interactive = TRUE
    )
})

output$transf_autocorr_plot <- renderPlotly({
  data_transformed() |>
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, 
      .lags = input$transf_acf_lag, # ifelse(ts_freq() < 60, ts_freq() * 3, 150)
      .interactive = TRUE,
      .title = "Autocorrelation", .y_lab = NULL,
    )
})

output$transf_decomp_plot <- renderPlotly({
    data_transformed() |>
      timetk::plot_stl_diagnostics(
    .date_var = date, .value = value, 
    .feature_set = c("season", "trend", "remainder"), .interactive = TRUE,
    .title = "Decomposition"
  )
})

output$transf_season_plot <- renderPlotly({
  data_transformed() |>
    timetk::plot_seasonal_diagnostics(
      .date_var = date, .value = value, 
      .interactive = TRUE, .title = "Seasonality"
    )
})
```


Row 1 {data-height=400}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
plotlyOutput(outputId = "transf_ts_plot_smooth")
```

### {.no-padding}

```{r}
plotlyOutput(outputId = "transf_autocorr_plot")
```


Row 2 {data-height=600}
---------------------------------------------------------------------------

### {.no-padding}

```{r}
plotlyOutput(outputId = "transf_decomp_plot")
```

### {.no-padding}

```{r}
plotlyOutput(outputId = "transf_season_plot")
```



Feature Engineering {data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
```

Row 1 {data-height=500}
---------------------------------------------------------------------------

### Features {.no-padding}

COMING SOON


Test & Evaluate {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Test & Evaluate* 
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "method", label = h3("Forecast Algorithm"), multiple = FALSE,
  choices = list(
    `Time Series` = ts_methods, 
    `Machine Learning` = ml_methods,
    `Deep Learning` = dl_methods,
    `Mixed Algorithms` = mix_methods,
    `Auto ML` = aml_methods
  ), 
  selected = "Naive"
)

awesomeCheckbox(inputId = "back_transf", label = "Back transform?", value = FALSE)

actionButton(inputId = "apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "tsf_reset", label = "Reset", icon = icon("sync"))

br() # break rule
br() # break rule

# Naive
conditionalPanel(
  condition = "input.method == 'Naive'",
  h5("Algorithm hyperparameters: "),
  h6("No hyperparameters for this algorithm!")
)

# Seasonal Naive
conditionalPanel(
  condition = "input.method == 'Seasonal Naive'",
  h5("Algorithm hyperparameters: "),
  h6("No hyperparameters for this algorithm!")
)

# Rolling Average
conditionalPanel(
  condition = "input.method == 'Rolling Average'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "window_size", label = "Window Size", value = get_default("window_size"), min = 1)
)

# ETS
conditionalPanel(
  condition = "input.method == 'ETS'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_ets", label = "Automatic estimation?", value = get_default("auto_ets")),
  selectInput(inputId = "error", label = "Error", choices = c("additive", "multiplicative"), selected = get_default("error")),
  selectInput(inputId = "trend", label = "Trend", choices = c("additive", "multiplicative", "none"), selected = get_default("trend")),
  selectInput(inputId = "season", label = "Seasonality", choices = c("additive", "multiplicative", "none"), selected = get_default("season")),
  selectInput(inputId = "damping", label = "Damped Trend", choices = c("damped", "none"), selected = get_default("damping")),
  numericInput(inputId = "smooth_level", label = "Alpha", value = get_default("smooth_level"), min = 0, max = 1),
  numericInput(inputId = "smooth_trend", label = "Beta", value = get_default("smooth_trend"), min = 0, max = 1),
  numericInput(inputId = "smooth_season", label = "Gamma", value = get_default("smooth_season"), min = 0, max = 1)
)

# Theta
conditionalPanel(
  condition = "input.method == 'Theta'",
  h5("Algorithm hyperparameters: "),
  h6("No hyperparameters for this algorithm!"),
  h6("This algorithm is fully automatic!")
)

# SARIMA
conditionalPanel(
  condition = "input.method == 'SARIMA'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_arima", label = "Automatic estimation?", value = get_default("auto_arima")),
  sliderInput(inputId = "non_seasonal_ar", label = "p", value = get_default("non_seasonal_ar"), min = 0, max = 5, step = 1),
  sliderInput(inputId = "non_seasonal_differences", label = "d", value = get_default("non_seasonal_differences"), min = 0, max = 2, step = 1),
  sliderInput(inputId = "non_seasonal_ma", label = "q", value = get_default("non_seasonal_ma"), min = 0, max = 5, step = 1),
  sliderInput(inputId = "seasonal_ar", label = "P", value = get_default("seasonal_ar"), min = 0, max = 5, step = 1),
  sliderInput(inputId = "seasonal_differences", label = "D", value = get_default("seasonal_differences"), min = 0, max = 2, step = 1),
  sliderInput(inputId = "seasonal_ma", label = "Q", value = get_default("seasonal_ma"), min = 0, max = 5, step = 1)
)

# TBATS
conditionalPanel(
  condition = "input.method == 'TBATS'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_tbats", label = "Automatic estimation?", value = get_default("auto_tbats")),
  numericInput(inputId = "tbats_seasonal_period_1", label = "Seasonal Period 1", value = get_default("tbats_seasonal_period_1"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "tbats_seasonal_period_2", label = "Seasonal Period 2", value = get_default("tbats_seasonal_period_2"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "tbats_seasonal_period_3", label = "Seasonal Period 3", value = get_default("tbats_seasonal_period_3"), min = 0, max = Inf, step = 1)
)

# STLM
conditionalPanel(
  condition = "input.method == 'STLM'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_stlm", label = "Automatic estimation?", value = get_default("auto_stlm")),
  prettyRadioButtons(inputId = "trend_model", label = "Trend Model", choices = c("ETS", "ARIMA"), inline = TRUE, selected = get_default("trend_model")),
  numericInput(inputId = "stlm_seasonal_period_1", label = "Seasonal Period 1", value = get_default("stlm_seasonal_period_1"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "stlm_seasonal_period_2", label = "Seasonal Period 2", value = get_default("stlm_seasonal_period_2"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "stlm_seasonal_period_3", label = "Seasonal Period 3", value = get_default("stlm_seasonal_period_3"), min = 0, max = Inf, step = 1)
)

# Prophet
conditionalPanel(
  condition = "input.method == 'Prophet'",
  h5("Algorithm hyperparameters: "),
  awesomeCheckbox(inputId = "auto_prophet", label = "Automatic estimation?", value = get_default("auto_prophet")),
  prettyRadioButtons(inputId = "growth", label = "Growth", choices = c("linear", "logistic"), inline = TRUE, selected = get_default("growth")),
  conditionalPanel(
    condition = "input.growth == 'logistic'",
    numericInput(inputId = "logistic_cap", label = "Logistic Cap", value = get_default("logistic_cap"), min = -Inf, max = Inf, step = 1),
    numericInput(inputId = "logistic_floor", label = "Logistic Floor", value = get_default("logistic_floor"), min = -Inf, max = Inf, step = 1)
  ),
  numericInput(inputId = "changepoint_num", label = "Changepoints Num", value = get_default("changepoint_num"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "changepoint_range", label = "Changepoints Range", value = get_default("changepoint_range"), min = 0, max = 1),
  prettyRadioButtons(inputId = "prophet_season", label = "Seasonality", choices = c("additive", "multiplicative"), inline = TRUE, selected = get_default("prophet_season")),
  awesomeCheckbox(inputId = "seasonality_yearly", label = "Yearly Seasonality?", value = get_default("seasonality_yearly")),
  awesomeCheckbox(inputId = "seasonality_weekly", label = "Weekly Seasonality?", value = get_default("seasonality_weekly")),
  awesomeCheckbox(inputId = "seasonality_daily", label = "Daily Seasonality?", value = get_default("seasonality_daily")),
  numericInput(inputId = "prior_scale_changepoints", label = "Changepoint Flexibility", value = get_default("prior_scale_changepoints") , min = 0, max = 1),
  numericInput(inputId = "prior_scale_seasonality", label = "Seasonality Stength", value = get_default("prior_scale_seasonality"), min = 0, max = Inf),
  numericInput(inputId = "prior_scale_holidays", label = "Holidays Strength", value = get_default("prior_scale_holidays"), min = 0, max = Inf)
)

# Linear Regression
conditionalPanel(
  condition = "input.method == 'Linear Regression'",
  h5("Algorithm hyperparameters: "),
  h6("No hyperparameters for this algorithm!")
)

# Elastic Net
conditionalPanel(
  condition = "input.method == 'Elastic Net'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "penalty", label = "Penalty", value = get_default("penalty"), min = 0, max = 100),
  numericInput(inputId = "mixture", label = "Mixture", value = get_default("mixture"), min = 0, max = 1)
)

# MARS
conditionalPanel(
  condition = "input.method == 'MARS'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "num_terms", label = "Num Terms", value = get_default("num_terms"), min = 0, max = 200),
  sliderInput(inputId = "prod_degree", label = "Interactions Degree", value = get_default("prod_degree"), min = 0, max = 5, step = 1),
  selectInput(inputId = "prune_method", label = "Prune Method", choices = c("backward", "forward", "none"), selected = get_default("prune_method"))
)

# KNN
conditionalPanel(
  condition = "input.method == 'KNN'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "neighbors", label = "K-neighbors", value = get_default("neighbors"), min = 0, max = Inf)
)

# SVM
conditionalPanel(
  condition = "input.method == 'SVM'",
  h5("Algorithm hyperparameters: "),
  prettyRadioButtons(inputId = "boundary", label = "Boundary Type", choices = c("Linear", "Radial"), inline = TRUE, selected = get_default("boundary")),
  numericInput(inputId = "cost", label = "Cost", value = get_default("cost"), min = 0, max = Inf),
  numericInput(inputId = "margin", label = "Margin", value = get_default("margin"), min = 0, max = Inf),
  conditionalPanel(
    condition = "input.boundary == 'Radial'",
    numericInput(inputId = "rbf_sigma", label = "Sigma", value = get_default("rbf_sigma"), min = 0, max = Inf)
  )
)

# Random Forest
conditionalPanel(
  condition = "input.method == 'Random Forest'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "rf_mtry", label = "Random Predictors", value = get_default("rf_mtry"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "rf_trees", label = "Trees", value = get_default("rf_trees"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "rf_min_n", label = "Min Node Size", value = get_default("rf_min_n"), min = 1, max = Inf, step = 1)
)

# Boosted Trees
conditionalPanel(
  condition = "input.method == 'Boosted Trees'",
  h5("Algorithm hyperparameters: "),
  prettyRadioButtons(
    inputId = "boost_method", label = "Boosting Method", 
    choices = c("XGBoost", "LightGBM"), 
    inline = TRUE, selected = get_default("boost_method")
  ),
  numericInput(inputId = "boost_mtry", label = "Random Predictors", value = get_default("boost_mtry"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "boost_trees", label = "Trees", value = get_default("boost_trees"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "boost_min_n", label = "Min Node Size", value = get_default("boost_min_n"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "boost_tree_depth", label = "Tree Depth", value = get_default("boost_tree_depth"), min = 1, max = Inf),
  numericInput(inputId = "boost_learn_rate", label = "Learning Rate", value = get_default("boost_learn_rate"), min = 0, max = 1),
  numericInput(inputId = "boost_loss_reduction", label = "Min Loss Reduction", value = get_default("boost_loss_reduction"), min = 0, max = 1),
  numericInput(inputId = "boost_sample_size", label = "Sample Size", value = get_default("boost_sample_size"), min = 0, max = 1)
)

# Cubist
conditionalPanel(
  condition = "input.method == 'Cubist'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "committees", label = "Num Members", value = get_default("committees"), min = 0, max = 100, step = 1),
  sliderInput(inputId = "cub_neighbors", label = "Neighbors", value = get_default("cub_neighbors"), min = 0, max = 9, step = 1),
  numericInput(inputId = "max_rules", label = "Max Rules", value = get_default("max_rules"), min = 1, max = Inf, step = 1)
)

# Feed-Forward
conditionalPanel(
  condition = "input.method == 'Feed-Forward'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "ff_hidden_units", label = "Hidden Units", value = get_default("ff_hidden_units"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "ff_penalty", label = "Decay", value = get_default("ff_penalty"), min = 0, max = 1),
  numericInput(inputId = "ff_epochs", label = "Epochs", value = get_default("ff_epochs"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "ff_dropout", label = "Dropout", value = get_default("ff_dropout"), min = 0, max = 1),
  numericInput(inputId = "ff_learn_rate", label = "Learning Rate", value = get_default("ff_learn_rate"), min = 0, max = 1),
)

# Feed-Forward AR
conditionalPanel(
  condition = "input.method == 'Feed-Forward AR'",
  h5("Algorithm hyperparameters: "),
  sliderInput(inputId = "ffar_non_seasonal_ar", label = "p", value = get_default("ffar_non_seasonal_ar"), min = 0, max = 5, step = 1),
  sliderInput(inputId = "ffar_seasonal_ar", label = "P", value = get_default("ffar_seasonal_ar"), min = 0, max = 5, step = 1),
  numericInput(inputId = "ffar_hidden_units", label = "Hidden Units", value = get_default("ffar_hidden_units"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "ffar_penalty", label = "Decay", value = get_default("ffar_penalty"), min = 0, max = 1),
  numericInput(inputId = "ffar_epochs", label = "Epochs", value = get_default("ffar_epochs"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "ffar_num_networks", label = "Num Networks", value = get_default("ffar_num_networks"), min = 1, max = Inf, step = 1)
)

# ARIMA-Boost
conditionalPanel(
  condition = "input.method == 'ARIMA-Boost'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "arima_boost_mtry", label = "Random Predictors", value = get_default("arima_boost_mtry"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "arima_boost_trees", label = "Trees", value = get_default("arima_boost_trees"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "arima_boost_min_n", label = "Min Node Size", value = get_default("arima_boost_min_n"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "arima_boost_tree_depth", label = "Tree Depth", value = get_default("arima_boost_tree_depth"), min = 1, max = Inf),
  numericInput(inputId = "arima_boost_learn_rate", label = "Learning Rate", value = get_default("arima_boost_learn_rate"), min = 0, max = 1),
  numericInput(inputId = "arima_boost_loss_reduction", label = "Min Loss Reduction", value = get_default("arima_boost_loss_reduction"), min = 0, max = 1),
  numericInput(inputId = "arima_boost_sample_size", label = "Sample Size", value = get_default("arima_boost_sample_size"), min = 0, max = 1)
)

# Prophet-Boost
conditionalPanel(
  condition = "input.method == 'Prophet-Boost'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "prophet_boost_mtry", label = "Random Predictors", value = get_default("prophet_boost_mtry"), min = 0, max = Inf, step = 1),
  numericInput(inputId = "prophet_boost_trees", label = "Trees", value = get_default("prophet_boost_trees"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "prophet_boost_min_n", label = "Min Node Size", value = get_default("prophet_boost_min_n"), min = 1, max = Inf, step = 1),
  numericInput(inputId = "prophet_boost_tree_depth", label = "Tree Depth", value = get_default("prophet_boost_tree_depth"), min = 1, max = Inf),
  numericInput(inputId = "prophet_boost_learn_rate", label = "Learning Rate", value = get_default("prophet_boost_learn_rate"), min = 0, max = 1),
  numericInput(inputId = "prophet_boost_loss_reduction", label = "Min Loss Reduction", value = get_default("prophet_boost_loss_reduction"), min = 0, max = 1),
  numericInput(inputId = "prophet_boost_sample_size", label = "Sample Size", value = get_default("prophet_boost_sample_size"), min = 0, max = 1)
)

# H2O AutoML
conditionalPanel(
  condition = "input.method == 'H2O AutoML'",
  h5("Algorithm hyperparameters: "),
  numericInput(inputId = "h2o_max_time", label = "Max Time (secs)", value = get_default("h2o_max_time"), min = 5, max = Inf, step = 1),
  numericInput(inputId = "h2o_max_time_model", label = "Max Time per Model (secs)", value = get_default("h2o_max_time_model"), min = 5, max = Inf, step = 1),
  sliderInput(inputId = "h2o_nfolds", label = "Folds", min = 2, max = 50, value = get_default("h2o_nfolds"), step = 1),
  selectInput(inputId = "h2o_metric", label = "Metric", choices = metrics, selected = get_default("h2o_metric"))
)

# Coming Soon!
conditionalPanel(
  condition = "input.method == 'COMING SOON!'",
  h5("New algorithms will be released soon!")
)
```

```{r}
observeEvent(
  eventExpr = input$tsf_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "n_future", value = 12)
    updateNumericInput(session = session, inputId = "n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "assess_type", selected = "Rolling")
    updatePickerInput(session = session, inputId = "method", selected = "Naive")
    updateAwesomeCheckbox(session = session, inputId = "back_transf", value = FALSE)
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "apply_forecast")})
  }
)

forecast_results <- eventReactive(
  eventExpr = input$apply_forecast,
  valueExpr = {
    map(
      input$method, 
      ~ fit_model(
        data = data_transformed(), method = ., params = input, 
        n_assess = input$n_assess, assess_type = input$assess_type, seed = 1992
      )
    ) |> 
      generate_forecast(
        data = data_transformed(), method = input$method, n_future = input$n_future,
        n_assess = input$n_assess, assess_type = input$assess_type
      )
  }
)

back_forecast_results <- reactive({
	req(forecast_results())
	forecast_results() |> 
		back_transform_forecast(
			transform = input$back_transf, 
			transformations = input$transf, 
			transform_params = transform_params()
		)
})


output$plot_test_forecast <- renderPlotly({
  back_forecast_results()$test_forecast |> 
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE, .conf_interval_fill = "lightblue")
})

# output$plot_splits <- renderPlotly({
#   forecast_results()$splits |>
#     tk_time_series_cv_plan() |>
#     plot_time_series_cv_plan(date, value, .title = NULL, .legend_show = FALSE)
# })

output$plot_oos_forecast <- renderPlotly({
  back_forecast_results()$oos_forecast |> 
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE, .conf_interval_fill = "lightblue")
})

output$accuracy_table <- renderDT({
	back_forecast_results()$accuracy |>	
    format_accuracy(single_method = TRUE) |>
    datatable(
      options = list(
        ordering = FALSE, pageLength = 20, lengthChange = FALSE, searching = FALSE,
        info = FALSE, paging = FALSE
      ), 
      rownames = FALSE
    )
})

output$model_summary <- renderPrint({
  back_forecast_results()$fit
})

output$plot_resid_ts <- renderPlotly({
  back_forecast_results()$residuals |> 
    select(.index, .residuals) |> 
    set_names(c("date", "value")) |> 
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = FALSE, .interactive = TRUE, .title = NULL
    )
})

output$plot_resid_acf <- renderPlotly({
  back_forecast_results()$residuals |> 
    select(.index, .residuals) |> 
    set_names(c("date", "value")) |> 
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, .lags = 60,
      .interactive = TRUE, .title = NULL, .y_lab = NULL,
    )
})
```


Row {data-height=500}
---------------------------------------------------------------------------

### Test Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_test_forecast")
```

<!-- ### Validation Plan {.no-padding} -->

<!-- ```{r} -->
<!-- plotlyOutput(outputId = "plot_splits") -->
<!-- ``` -->

### Out-of-Sample Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_oos_forecast")
```


Row {data-height=500} 
---------------------------------------------------------------------------

### Evaluation Metrics {.no-padding}

```{r}
DTOutput(outputId = "accuracy_table")
```

### Algorithm Summary {.no-padding}

```{r}
verbatimTextOutput(outputId = "model_summary")
```

### Residuals Time Plot {.no-padding}

```{r}
plotlyOutput(outputId = "plot_resid_ts")
```

### Residuals ACF {.no-padding}

```{r}
plotlyOutput(outputId = "plot_resid_acf")
```



Optimize {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Optimize*  
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "tune_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1
  ),
  numericInput(
    inputId = "tune_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1
  ), 
  prettyRadioButtons(
    inputId = "tune_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  prettyRadioButtons(
    inputId = "tune_valid_type", label = "Validation Type", 
    choices = c("Time Series CV", "K-Fold CV"), selected = "Time Series CV", 
    inline = TRUE
  ),
  sliderInput(
    inputId = "tune_n_folds", label = "Folds", 
    min = 2, max = 50, value = 5, step = 1
  ),
  selectInput(
    inputId = "tune_valid_metric", label = "Validation Metric", 
    choices = metrics, selected = "RMSE"
  ),
  awesomeCheckbox(inputId = "tune_bayes", label = "Use Bayes-Optim?", value = TRUE),
  sliderInput(
    inputId = "tune_grid_size", label = "Grid Size", 
    value = 10, min = 1, max = 200, step = 10
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "tune_method", label = h3("Forecast Algorithm"), multiple = FALSE,
  choices = list(
    `Machine Learning` = ml_methods[-1],
    `Deep Learning` = dl_methods,
    `Mixed Algorithms` = mix_methods
  ), 
  selected = "Elastic Net"
)

awesomeCheckbox(inputId = "tune_back_transf", label = "Back transform?", value = FALSE)

actionButton(inputId = "tune_apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "tune_reset", label = "Reset", icon = icon("sync"))

br() # break rule
br() # break rule

# Elastic Net
conditionalPanel(
  condition = "input.tune_method == 'Elastic Net'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_elanet", label = NULL, 
    choices = mtd_prm_names[["Elastic Net"]], multiple = TRUE, 
    selected = mtd_prm_names[["Elastic Net"]],
    options = list("actions-box" = TRUE)
  )
)

# MARS
conditionalPanel(
  condition = "input.tune_method == 'MARS'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_mars", label = NULL, 
    choices = mtd_prm_names[["MARS"]], multiple = TRUE, 
    selected = mtd_prm_names[["MARS"]][1:2],
    options = list("actions-box" = TRUE)
  )
)

# KNN
conditionalPanel(
  condition = "input.tune_method == 'KNN'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_knn", label = NULL, 
    choices = mtd_prm_names[["KNN"]], multiple = TRUE, 
    selected = mtd_prm_names[["KNN"]],
    options = list("actions-box" = TRUE)
  )
)

# SVM
conditionalPanel(
  condition = "input.tune_method == 'SVM'",
  h5("Algorithm hyperparameters to optimize: "),
  prettyRadioButtons(
    inputId = "tune_boundary", label = "Boundary Type", choices = c("Linear", "Radial"), 
    inline = TRUE, selected = get_default("boundary")
  ),
  conditionalPanel(
    condition = "input.tune_boundary == 'Linear'",
    pickerInput(
      inputId = "tune_svm_linear", label = NULL, multiple = TRUE,
      choices = mtd_prm_names[["SVM"]][-c(1, 4)], selected = mtd_prm_names[["SVM"]][2:3],
      options = list("actions-box" = TRUE)
    )
  ),
  conditionalPanel(
    condition = "input.tune_boundary == 'Radial'",
    pickerInput(
      inputId = "tune_svm_rbf", label = NULL, multiple = TRUE,
      choices = mtd_prm_names[["SVM"]][-1], selected = mtd_prm_names[["SVM"]][2:3],
      options = list("actions-box" = TRUE)
    )
  )
)

# Random Forest
conditionalPanel(
  condition = "input.tune_method == 'Random Forest'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_rf", label = NULL, 
    choices = mtd_prm_names[["Random Forest"]], multiple = TRUE, 
    selected = mtd_prm_names[["Random Forest"]],
    options = list("actions-box" = TRUE)
  )
)

# Boosted Trees
conditionalPanel(
  condition = "input.tune_method == 'Boosted Trees'",
  h5("Algorithm hyperparameters to optimize: "),
  prettyRadioButtons(
    inputId = "tune_boost_method", label = "Boosting Method", 
    choices = c("XGBoost", "LightGBM"), 
    inline = TRUE, selected = get_default("boost_method")
  ),
  pickerInput(
    inputId = "tune_boost", label = NULL, 
    choices = mtd_prm_names[["Boosted Trees"]][-1], multiple = TRUE, 
    selected = mtd_prm_names[["Boosted Trees"]][6],
    options = list("actions-box" = TRUE)
  )
)

# Cubist
conditionalPanel(
  condition = "input.tune_method == 'Cubist'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_cub", label = NULL, 
    choices = mtd_prm_names[["Cubist"]], multiple = TRUE, 
    selected = mtd_prm_names[["Cubist"]],
    options = list("actions-box" = TRUE)
  )
)

# Feed-Forward
conditionalPanel(
  condition = "input.tune_method == 'Feed-Forward'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_ff", label = NULL, 
    choices = mtd_prm_names[["Feed-Forward"]], multiple = TRUE, 
    selected = mtd_prm_names[["Feed-Forward"]][1:3],
    options = list("actions-box" = TRUE)
  )
)

# Feed-Forward AR
conditionalPanel(
  condition = "input.tune_method == 'Feed-Forward AR'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_ffar", label = NULL, 
    choices = mtd_prm_names[["Feed-Forward AR"]], multiple = TRUE, 
    selected = mtd_prm_names[["Feed-Forward AR"]][2:4],
    options = list("actions-box" = TRUE)
  )
)

# ARIMA-Boost
conditionalPanel(
  condition = "input.tune_method == 'ARIMA-Boost'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_arima_boost", label = NULL, 
    choices = mtd_prm_names[["ARIMA-Boost"]], multiple = TRUE, 
    selected = mtd_prm_names[["ARIMA-Boost"]][5],
    options = list("actions-box" = TRUE)
  )
)

# Prophet-Boost
conditionalPanel(
  condition = "input.tune_method == 'Prophet-Boost'",
  h5("Algorithm hyperparameters to optimize: "),
  pickerInput(
    inputId = "tune_prophet_boost", label = NULL, 
    choices = mtd_prm_names[["Prophet-Boost"]], multiple = TRUE, 
    selected = mtd_prm_names[["Prophet-Boost"]][5],
    options = list("actions-box" = TRUE)
  )
)

# Coming Soon!
conditionalPanel(
  condition = "input.tune_method == 'COMING SOON!'",
  h5("New algorithms will be released soon!")
)
```

```{r}
observeEvent(
  eventExpr = input$tune_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "tune_n_future", value = 12)
    updateNumericInput(session = session, inputId = "tune_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "tune_assess_type", selected = "Rolling")
    updatePrettyRadioButtons(session = session, inputId = "tune_valid_type", selected = "Time Series CV")
    updateSliderInput(session = session, inputId = "tune_n_folds", value = 5)
    updateSelectInput(session = session, inputId = "tune_valid_metric", selected = "RMSE")
    updateAwesomeCheckbox(session = session, inputId = "tune_bayes", value = TRUE)
    updateSliderInput(session = session, inputId = "tune_grid_size", value = 10)
    updateSelectInput(session = session, inputId = "tune_method", selected = "Elastic Net")
    updateAwesomeCheckbox(session = session, inputId = "tune_back_transf", value = FALSE)
    updatePickerInput(session = session, inputId = "tune_elanet", selected = mtd_prm_names[["Elastic Net"]])
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)

tune_results <- eventReactive(
  eventExpr = input$tune_apply_forecast,
  valueExpr = {
    map(
      input$tune_method, 
      ~ fit_model_tuning(
        data = data_transformed(), method = ., params = input, 
        n_assess = input$tune_n_assess, assess_type = input$tune_assess_type, 
        validation_type = input$tune_valid_type, n_folds = input$tune_n_folds,
        validation_metric = input$tune_valid_metric, 
        bayesian_optimization = input$tune_bayes, grid_size = input$tune_grid_size, 
        seed = 1992
      )
    ) |> 
      generate_forecast(
        data = data_transformed(), method = input$tune_method, n_future = input$tune_n_future,
        n_assess = input$tune_n_assess, assess_type = input$tune_assess_type
      )
  }
)

back_tune_results <- reactive({
	req(tune_results())
	tune_results() |> 
		back_transform_forecast(
			transform = input$tune_back_transf, 
			transformations = input$transf, 
			transform_params = transform_params()
		)
})

output$plot_tune_test_forecast <- renderPlotly({
  back_tune_results()$test_forecast |> 
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE, .conf_interval_fill = "lightblue")
})

# output$plot_tune_splits <- renderPlotly({
#   tune_results()$splits |>
#     tk_time_series_cv_plan() |>
#     plot_time_series_cv_plan(date, value, .title = NULL, .legend_show = FALSE)
# })

output$plot_tune_oos_forecast <- renderPlotly({
  back_tune_results()$oos_forecast |> 
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE, .conf_interval_fill = "lightblue")
})

output$tune_accuracy_table <- renderDT({
	back_tune_results()$accuracy |>
    format_accuracy(single_method = TRUE) |>
    datatable(
      options = list(
        ordering = FALSE, pageLength = 20, lengthChange = FALSE, searching = FALSE,
        info = FALSE, paging = FALSE
      ), 
      rownames = FALSE
    )
})

output$tune_model_summary <- renderPrint({
  tune_results()$fit
})

output$plot_tune_resid_ts <- renderPlotly({
  back_tune_results()$residuals |> 
    select(.index, .residuals) |> 
    set_names(c("date", "value")) |> 
    timetk::plot_time_series(
      .date_var = date, .value = value,
      .smooth = FALSE, .interactive = TRUE, .title = NULL
    )
})

output$plot_tune_resid_acf <- renderPlotly({
  back_tune_results()$residuals |> 
    select(.index, .residuals) |> 
    set_names(c("date", "value")) |> 
    timetk::plot_acf_diagnostics(
      .date_var = date, .value = value, .lags = 60,
      .interactive = TRUE, .title = NULL, .y_lab = NULL,
    )
})
```


Row {data-height=500}
---------------------------------------------------------------------------

### Test Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_tune_test_forecast")
```

<!-- ### Validation Plan {.no-padding} -->

<!-- ```{r} -->
<!-- plotlyOutput(outputId = "plot_tune_splits") -->
<!-- ``` -->

### Out-of-Sample Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_tune_oos_forecast")
```


Row {data-height=500} 
---------------------------------------------------------------------------

### Evaluation Metrics {.no-padding}

```{r}
DTOutput(outputId = "tune_accuracy_table")
```

### Algorithm Summary {.no-padding}

```{r}
verbatimTextOutput(outputId = "tune_model_summary")
```

### Residuals Time Plot {.no-padding}

```{r}
plotlyOutput(outputId = "plot_tune_resid_ts")
```

### Residuals ACF {.no-padding}

```{r}
plotlyOutput(outputId = "plot_tune_resid_acf")
```



Compare {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Compare*
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "comp_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "comp_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "comp_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "comp_method", label = h3("Forecast Algorithm"), multiple = TRUE,
  choices = list(
    `Time Series` = ts_methods, 
    `Machine Learning` = ml_methods,
    `Deep Learning` = dl_methods,
    `Mixed Algorithms` = mix_methods,
    `Auto ML` = aml_methods
  ), 
  selected = c("ETS", "SARIMA"), options = list("actions-box" = TRUE)
)

awesomeCheckbox(inputId = "comp_tune", label = "Use optimized algorithms?", value = FALSE)
awesomeCheckbox(inputId = "comp_back_transf", label = "Back transform?", value = FALSE)

actionButton(inputId = "comp_apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "comp_reset", label = "Reset", icon = icon("sync"))
```

```{r}
observeEvent(
  eventExpr = input$comp_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "comp_n_future", value = 12)
    updateNumericInput(session = session, inputId = "comp_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "comp_assess_type", selected = "Rolling")
    updatePickerInput(session = session, inputId = "comp_method", selected = c("ETS", "SARIMA"))
    updateAwesomeCheckbox(session = session, inputId = "comp_tune", value = FALSE)
    updateAwesomeCheckbox(session = session, inputId = "comp_back_transf", value = FALSE)
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)

compare_results <- eventReactive(
  eventExpr = input$comp_apply_forecast,
  valueExpr = {
    map(
      input$comp_method, 
      ~ fit_model(
        data = data_transformed(), method = ., params = input, 
        n_assess = input$comp_n_assess, assess_type = input$comp_assess_type, seed = 1992
      )
    ) |> 
      generate_forecast(
        data = data_transformed(), method = input$comp_method, n_future = input$comp_n_future,
        n_assess = input$comp_n_assess, assess_type = input$comp_assess_type
      )
  }
)

back_compare_results <- reactive({
	req(compare_results())
	compare_results() |> 
		back_transform_forecast(
			transform = input$comp_back_transf, 
			transformations = input$transf, 
			transform_params = transform_params()
		)
})

output$plot_comp_test_forecast <- renderPlotly({
  back_compare_results()$test_forecast |> 
    plot_modeltime_forecast(.legend_show = TRUE, .title = FALSE, .conf_interval_fill = "lightblue")
})

output$plot_comp_oos_forecast <- renderPlotly({
  back_compare_results()$oos_forecast |> 
    plot_modeltime_forecast(.legend_show = TRUE, .title = FALSE, .conf_interval_fill = "lightblue")
})

output$comp_accuracy_table <- renderDT({
	back_compare_results()$accuracy |>
    format_accuracy(single_method = FALSE) |>
    filter(Type == "Test") |> 
    datatable(
      options = list(
        ordering = TRUE, pageLength = 6, lengthChange = FALSE, searching = FALSE, 
        info = FALSE, paging = FALSE, scrollCollapse = TRUE, scrollY = 300
      ), 
      rownames = FALSE
    )
})

output$comp_model_summary <- renderPrint({
  compare_results()$fit
})
```


Row {data-height=500}
---------------------------------------------------------------------------

### Test Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_comp_test_forecast")
```

### Out-of-Sample Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_comp_oos_forecast")
```


Row {data-height=500} 
---------------------------------------------------------------------------

### Evaluation Metrics {data-width=700 .no-padding}

```{r}
DTOutput(outputId = "comp_accuracy_table")
```

### Algorithm Summary {data-width=300 .no-padding}

```{r}
verbatimTextOutput(outputId = "comp_model_summary")
```



Explain {data-navmenu="Forecast" data-orientation=columns}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Explain*  
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
	numericInput(
    inputId = "exp_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "exp_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "exp_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "exp_method", label = h3("Forecast Algorithm"), multiple = FALSE,
  choices = list(
    `Machine Learning` = ml_methods,
    `Deep Learning` = dl_methods,
    `Mixed Algorithms` = mix_methods,
    `Auto ML` = aml_methods
  ), 
  selected = "Random Forest"
)

awesomeCheckbox(inputId = "exp_tune", label = "Use optimized algorithm?", value = FALSE)
awesomeCheckbox(inputId = "exp_back_transf", label = "Back transform?", value = FALSE)

actionButton(inputId = "exp_apply_forecast", label = "Explain!", icon = icon("play"))
actionButton(inputId = "exp_reset", label = "Reset", icon = icon("sync"))

br()
br()
br()

pickerInput(
  inputId = "exp_features", label = h5("Feature to explain"), multiple = FALSE,
  choices = NULL, selected = NULL, options = list("actions-box" = TRUE)
)
dateInput(
	inputId = "exp_date", label = h5("Date to explain"), value = NULL,
	min = as.Date("1940-01-01"), max = Sys.Date()
)
```

```{r}
observeEvent(
  eventExpr = input$exp_reset, 
  handlerExpr = {
  	updateNumericInput(session = session, inputId = "exp_n_future", value = 12)
    updateNumericInput(session = session, inputId = "exp_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "exp_assess_type", selected = "Rolling")
    updateSelectInput(session = session, inputId = "exp_method", selected = "Random Forest")
    updateCheckboxInput(session = session, inputId = "exp_tune", value = FALSE)
    updateCheckboxInput(session = session, inputId = "exp_back_transf", value = FALSE)
    updateTextInput(session = session, inputId = "exp_features", value = "")
    updateTextInput(session = session, inputId = "exp_date", value = "")
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)

explainer_results <- eventReactive(
  eventExpr = input$exp_apply_forecast,
  valueExpr = {
   	data_transformed() |>
		generate_model_explainer(
			method = input$exp_method, params = input,
			n_assess = input$exp_n_assess, assess_type = input$exp_assess_type
		)
  }
)

observeEvent(
  eventExpr = input$exp_apply_forecast,
  handlerExpr = {
  	req(explainer_results())
    updatePickerInput(
    	session = session, inputId = "exp_features",
    	choices = explainer_results()$features,
    	selected = explainer_results()$features[2]
    )
  }
)

observeEvent(
  eventExpr = input$exp_apply_forecast,
  handlerExpr = {
    req(data_transformed())
    updateDateInput(
      session = session, inputId = "exp_date", 
      value = dplyr::slice_tail(data_transformed(), n = input$exp_n_assess)$date[1], 
      min = dplyr::slice_tail(data_transformed(), n = input$exp_n_assess)$date[1], 
      max = dplyr::slice_tail(data_transformed(), n = input$exp_n_assess)$date[input$exp_n_assess]
    )
  }
)

exp_observation <- reactive({
  req(data_transformed())
  req(explainer_results())
  req(input$exp_date)
  get_observation(
  	data = data_transformed(), date = input$exp_date, method = input$exp_method,
  	n_assess = input$exp_n_assess, assess_type = input$exp_assess_type
  )
})
	
output$exp_features_table <- renderDT({
  req(explainer_results()) 
	tibble::tibble(explainer_results()$features) |>
		datatable(
      options = list(
        ordering = FALSE, pageLength = 50, lengthChange = FALSE, searching = FALSE,
        info = FALSE, paging = FALSE, scrollY = 760, scrollCollapse = TRUE
      ),
      rownames = FALSE, colnames = ""
    )
})

output$plot_exp_featimp <- renderPlot({
	req(explainer_results())
	explainer_results()$explainer |> 
		explain_model(type = "feature_importance") |>
		plot() + labs(title = NULL, subtitle = NULL, caption = NULL)
})

output$plot_exp_varresp <- renderPlot({
	req(explainer_results())
	req(input$exp_features)
	explainer_results()$explainer |> 
		explain_model(type = "variable_response",	features = input$exp_features) |>
		plot() + labs(title = NULL, subtitle = NULL, caption = NULL)	
})

output$plot_exp_bd <- renderPlot({
	req(explainer_results())
	req(exp_observation())
	explainer_results()$explainer |> 
		explain_model(type = "break_down", observation = exp_observation()) |>
		plot() + labs(title = NULL, subtitle = NULL, caption = NULL)
})

output$plot_exp_locstab <- renderPlot({
	req(data_transformed())
	req(explainer_results())
	req(exp_observation())
	req(input$exp_features)
	explainer_results()$explainer |> 
		explain_model(
			type = "local_stability",	observation = exp_observation(), 
			features = input$exp_features
		) |>
		plot() + labs(title = NULL, subtitle = NULL, caption = NULL)
})
```


Column {data-width=150}
---------------------------------------------------------------------------

### Features {.no-padding}

```{r}
DTOutput(outputId = "exp_features_table")
```


Column {data-width=425}
---------------------------------------------------------------------------

### Feature Importance {data-height=700 .no-padding}

```{r}
plotOutput(outputId = "plot_exp_featimp")
```

### Variable Response Analysis {data-height=300, .no-padding}

```{r}
plotOutput(outputId = "plot_exp_varresp")
```


Column {data-width=425}
---------------------------------------------------------------------------

### Break-Down Analysis {.no-padding}

```{r}
plotOutput(outputId = "plot_exp_bd")
```

### Local Stability Analysis {.no-padding}

```{r}
plotOutput(outputId = "plot_exp_locstab")
```



Combine {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Combine*
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "ens_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "ens_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "ens_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "ens_method", label = h3("Forecast Algorithms"), 
  choices = list(
    `Time Series` = ts_methods, 
    `Machine Learning` = ml_methods,
    `Deep Learning` = dl_methods,
    `Mixed Algorithms` = mix_methods,
    `Auto ML` = aml_methods
  ), 
  selected = c("ETS", "SARIMA"), multiple = TRUE,
  options =  list(
    "actions-box" = FALSE,
    "max-options" = 5,
    "max-options-text" = "You can combine maximum 5 algorithms!"
  )
)

awesomeCheckbox(inputId = "ens_tune", label = "Use optimized algorithms?", value = FALSE)
awesomeCheckbox(inputId = "ens_back_transf", label = "Back transform?", value = FALSE)

pickerInput(
  inputId = "ens_type", label = h3("Ensemble Method"), 
  choices = ens_methods, selected = "Average", multiple = TRUE,
  options =  list("actions-box" = TRUE)
)
actionButton(inputId = "ens_apply_forecast", label = "Forecast!", icon = icon("play"))

br()
br()

pickerInput(
  inputId = "stk_type", label = h3("Stacking Method"), 
  choices = stk_methods, selected = "Linear Regression", multiple = TRUE,
  options =  list("actions-box" = TRUE)
)
awesomeCheckbox(inputId = "stk_tune", label = "Optimize stack?", value = FALSE)

actionButton(inputId = "stk_apply_forecast", label = "Forecast!", icon = icon("play"))

br()
br()
br()

actionButton(inputId = "ens_reset", label = "Reset", icon = icon("sync"))
```

```{r}
observeEvent(
  eventExpr = input$ens_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "ens_n_future", value = 12)
    updateNumericInput(session = session, inputId = "ens_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "ens_assess_type", selected = "Rolling")
    updatePickerInput(session = session, inputId = "ens_method", selected = c("ETS", "SARIMA"))
    updateAwesomeCheckbox(session = session, inputId = "ens_tune", value = FALSE)
    updateAwesomeCheckbox(session = session, inputId = "ens_back_transf", value = FALSE)
    updatePickerInput(session = session, inputId = "ens_type", selected = "Average")
    updatePickerInput(session = session, inputId = "stk_type", selected = "Linear Regression")
    updateAwesomeCheckbox(session = session, inputId = "stk_tune", value = FALSE)
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)

react_val <- reactiveValues(combine_results = NULL)

observeEvent(
  eventExpr = input$ens_apply_forecast, 
  handlerExpr = {
    react_val$combine_results <-
      map(
        input$ens_method,
        ~ fit_model(
          data = data_transformed(), method = ., params = input,
          n_assess = input$ens_n_assess, assess_type = input$ens_assess_type, seed = 1992
        )
      ) |>
      generate_forecast(
        data = data_transformed(), method = input$ens_method,
        n_future = input$ens_n_future, n_assess = input$ens_n_assess,
        assess_type = input$ens_assess_type, ensemble_methods = input$ens_type,
        stacking_methods = NULL
      )
  }
)

observeEvent(
  eventExpr = input$stk_apply_forecast, 
  handlerExpr = {
    react_val$combine_results <-
      map(
        input$ens_method,
        ~ fit_model(
          data = data_transformed(), method = ., params = input,
          n_assess = input$ens_n_assess, assess_type = input$ens_assess_type, seed = 1992
        )
      ) |>
      generate_forecast(
        data = data_transformed(), method = input$ens_method,
        n_future = input$ens_n_future, n_assess = input$ens_n_assess,
        assess_type = input$ens_assess_type, ensemble_methods = NULL,
        stacking_methods = input$stk_type
      )
  }
)

back_combine_results <- reactive({
	req(react_val$combine_results)
	react_val$combine_results |> 
		back_transform_forecast(
			transform = input$ens_back_transf, 
			transformations = input$transf, 
			transform_params = transform_params()
		)
})

output$plot_ens_test_forecast <- renderPlotly({
  back_combine_results()$test_forecast |> 
    plot_modeltime_forecast(.legend_show = TRUE, .title = FALSE, .conf_interval_fill = "lightblue")
})

output$plot_ens_oos_forecast <- renderPlotly({
	back_combine_results()$oos_forecast |> 
    plot_modeltime_forecast(.legend_show = TRUE, .title = FALSE, .conf_interval_fill = "lightblue")
})

output$ens_accuracy_table <- renderDT({
	back_combine_results()$accuracy |> 
    format_accuracy(single_method = FALSE) |>
    filter(Type == "Test") |>
    datatable(
      options = list(
        ordering = TRUE,
        pageLength = 6,
        lengthChange = FALSE,
        searching = FALSE,
        info = FALSE,
        paging = FALSE,
        scrollCollapse = TRUE,
        scrollY = 300
      ),
      rownames = FALSE
    )
})

output$ens_model_summary <- renderPrint({
  req(react_val$combine_results$fit)
  react_val$combine_results$fit
})
```


Row {data-height=500}
---------------------------------------------------------------------------

### Test Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_ens_test_forecast")
```

### Out-of-Sample Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_ens_oos_forecast")
```


Row {data-height=500} 
---------------------------------------------------------------------------

### Evaluation Metrics {data-width=700 .no-padding}

```{r}
DTOutput(outputId = "ens_accuracy_table")
```

### Algorithm Summary {data-width=300 .no-padding}

```{r}
verbatimTextOutput(outputId = "ens_model_summary")
```



Scenario Analysis {data-navmenu="Forecast" data-orientation=rows}
===========================================================================

Input {.sidebar}
---------------------------------------------------------------------------

*Forecast - Scenario*
```{r}
useShinyjs(rmd = TRUE) # use Shiny JavaScript to allow delay on buttons
dropdownButton(
  numericInput(
    inputId = "scn_n_future", label = "Forecast Horizon", 
    value = 12, min = 1, max = Inf, step = 1, width = "100%"
  ),
  numericInput(
    inputId = "scn_n_assess", label = "Assessment Period", 
    value = 24, min = 1, max = Inf, step = 1, width = "100%"
  ), 
  prettyRadioButtons(
    inputId = "scn_assess_type", label = "Assessment Type", 
    choices = c("Expanding", "Rolling"), selected = "Rolling", 
    inline = TRUE
  ),
  icon = icon("gear"), width = "200px", size = "sm", circle = TRUE,
  tooltip = tooltipOptions(title = "Click to see inputs!")
)

pickerInput(
  inputId = "scn_method", label = h3("Forecast Algorithm"), multiple = FALSE,
  choices = list(
    `Time Series` = ts_methods, 
    `Machine Learning` = ml_methods,
    `Deep Learning` = dl_methods,
    `Mixed Algorithms` = mix_methods,
    `Auto ML` = aml_methods
  ), 
  selected = "ETS"
)

awesomeCheckbox(inputId = "scn_tune", label = "Use optimized algorithm?", value = FALSE)
awesomeCheckbox(inputId = "scn_back_transf", label = "Back transform?", value = FALSE)

actionButton(inputId = "scn_apply_forecast", label = "Forecast!", icon = icon("play"))
actionButton(inputId = "scn_reset", label = "Reset", icon = icon("sync"))

br()
br()
br()

sliderInput(
  inputId = "scn_conf_lvl", label = h5("Confidence Level"), 
  min = 0.05, max = 0.99, value = 0.9, step = 0.05
)
selectInput(
  inputId = "scn_aggreg_fun", label = h5("Aggregation Function"), 
  choices = getOption("tsf.dashboard.aggreg_funs"), selected = "sum"
)
numericInput(
  inputId = "scn_adjust", label = h5("Business Adjustment (%)"), 
  value = 0, min = -Inf, max = Inf, step = 5
)
```

```{r}
observeEvent(
  eventExpr = input$scn_reset, 
  handlerExpr = {
    updateNumericInput(session = session, inputId = "scn_n_future", value = 12)
    updateNumericInput(session = session, inputId = "scn_n_assess", value = 24)
    updatePrettyRadioButtons(session = session, inputId = "scn_assess_type", selected = "Rolling")
    updateSelectInput(session = session, inputId = "scn_method", selected = "ETS")
    updateAwesomeCheckbox(session = session, inputId = "scn_tune", value = FALSE)
    updateAwesomeCheckbox(session = session, inputId = "scn_back_transf", value = FALSE)
    updateSliderInput(session = session, inputId = "scn_conf_lvl", value = 0.9)
    updateSelectInput(session = session, inputId = "scn_aggreg_fun", selected = "sum")
    updateNumericInput(session = session, inputId = "scn_adjust", value = 0)
    # shinyjs::delay(ms = 300, expr = {shinyjs::click(id = "tune_apply_forecast")})
  }
)

react_val <- reactiveValues(aggregate_n_future = NULL)

observeEvent(
  eventExpr = input$scn_apply_forecast, 
  handlerExpr = {
    react_val$aggregate_n_future <- input$scn_n_future
  }
)

scenario_results <- eventReactive(
  eventExpr = input$scn_apply_forecast,
  valueExpr = {
    map(
      input$scn_method, 
      ~ fit_model(
        data = data_transformed(), method = ., params = input, 
        n_assess = input$scn_n_assess, assess_type = input$scn_assess_type, seed = 1992
      )
    ) |> 
      generate_forecast(
        data = data_transformed(), method = input$scn_method, n_future = input$scn_n_future,
        n_assess = input$scn_n_assess, assess_type = input$scn_assess_type, 
        confidence_level = c(0.05, 0.99)
      )
  }
)

back_scenario_results <- reactive({
	req(scenario_results())
	scenario_results() |> 
		back_transform_forecast(
			transform = input$scn_back_transf, 
			transformations = input$transf, 
			transform_params = transform_params()
		)
})

output$plot_scn_oos_forecast_fan <- renderPlotly({
  back_scenario_results()$oos_forecast |> 
    filter(.key == "actual" | .conf_lvl == as.character(input$scn_conf_lvl)) |> 
		adjust_forecast(input$scn_adjust) |>
    plot_modeltime_forecast(.legend_show = FALSE, .title = FALSE, .conf_interval_fill = "lightblue")
})

output$plot_scn_oos_forecast_wb <- renderPlotly({
  g <- back_scenario_results()$oos_forecast |> 
  	filter(.key == "actual" | .conf_lvl == as.character(input$scn_conf_lvl)) |> 
  	adjust_forecast(input$scn_adjust) |>
    modeltime::plot_modeltime_forecast(
      .interactive = FALSE, .conf_interval_show = FALSE, .legend_show = FALSE, .title = FALSE
    ) +
      ggplot2::geom_line(aes(x = .index, y = .conf_lo), col = "darkred", linetype = 2) +
      ggplot2::geom_line(aes(x = .index, y = .conf_hi), col = "darkgreen", linetype = 2)
  plotly::ggplotly(g, dynamicTicks = TRUE)
})

output$scn_accuracy_table <- renderDT({
	back_scenario_results()$accuracy |> 
    format_accuracy(single_method = TRUE) |>
    select(-Train) |> 
    datatable(
      options = list(
        ordering = FALSE, pageLength = 20, lengthChange = FALSE, searching = FALSE,
        info = FALSE, paging = FALSE
      ), 
      rownames = FALSE
    )
})

output$scn_aggregate_table <- renderDT({
  back_scenario_results()$oos_forecast |>
		filter(.key == "actual" | .conf_lvl == as.character(input$scn_conf_lvl)) |> 
    adjust_forecast(input$scn_adjust) |>
    aggregate_forecast(react_val$aggregate_n_future, input$scn_conf_lvl, input$scn_aggreg_fun) |> 
    mutate(across(.cols = where(is.numeric), .fns = ~ round(., 2))) |>
    datatable(
      options = list(
        ordering = FALSE, pageLength = 20, lengthChange = FALSE, searching = FALSE,
        info = FALSE, paging = FALSE
      ), 
      rownames = FALSE
    )
})

output$scn_wb_table <- renderDT({
  back_scenario_results()$oos_forecast |>
		filter(.key == "prediction" & .conf_lvl == as.character(input$scn_conf_lvl)) |> 
    adjust_forecast(input$scn_adjust) |>
    select(.index, .conf_lo, .value, .conf_hi) |> 
    mutate(across(.cols = where(is.numeric), .fns = ~ round(., 2))) |> 
    set_names(c("Date", "Worst Case", "Forecast", "Best Case")) |> 
    datatable(
      options = list(
        ordering = FALSE, pageLength = 20, lengthChange = FALSE, searching = FALSE,
        info = FALSE, paging = FALSE, scrollY = 350, scrollCollapse = TRUE
      ), 
      rownames = TRUE
    )
})
```


Row {data-height=500}
---------------------------------------------------------------------------

### Out-of-Sample Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_scn_oos_forecast_fan")
```

### Scenario Forecasts {.no-padding}

```{r}
plotlyOutput(outputId = "plot_scn_oos_forecast_wb")
```


Row {data-height=500} 
---------------------------------------------------------------------------

### Evaluation Metrics {data-width=100 .no-padding}

```{r}
DTOutput(outputId = "scn_accuracy_table")
```

### Aggregate Resuts {data-width=397 .no-padding}

```{r}
DTOutput(outputId = "scn_aggregate_table")
```

### Scenario Results {data-width=503 .no-padding}

```{r}
DTOutput(outputId = "scn_wb_table")
```
